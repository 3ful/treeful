[
  {
    "objectID": "index.html#about-this-book",
    "href": "index.html#about-this-book",
    "title": "Treeful Docs",
    "section": "About this Book",
    "text": "About this Book\nThis book is the documentation for Treeful, an R Shiny application helping people plant trees based on species distribution modelling.\n\n\nThis project was funded from the German ministry for Education and Research from March 1st 2023 to September 1st 2023."
  },
  {
    "objectID": "index.html#who-is-behind-this",
    "href": "index.html#who-is-behind-this",
    "title": "Treeful Docs",
    "section": "Who is behind this",
    "text": "Who is behind this\nTwo data scientists as part of the Prototype Fund:\n\nJakob Kutsch\nChristoph Trost"
  },
  {
    "objectID": "index.html#about-this-project-and-technical-approach",
    "href": "index.html#about-this-project-and-technical-approach",
    "title": "Treeful Docs",
    "section": "About this Project and technical Approach",
    "text": "About this Project and technical Approach\nThe purpose is to build a shiny app that allows user to explore habitat shapes of trees in Europe. These habitat shapes are plots of existing trees from a merged database of close to 9 million trees. We extracted climatic variables present at each tree location. These shapes allow users to compare with their own location, a potential planting site, for the past and future.\nHere’s an example what we mean with tree suitability: The scatter points are tree occurrences, with points from one location in te Harz mountains at different points in time, and 2070 projected. That place has already fallen out of the habitat of picea abies."
  },
  {
    "objectID": "index.html#infrastructure",
    "href": "index.html#infrastructure",
    "title": "Treeful Docs",
    "section": "Infrastructure",
    "text": "Infrastructure\nThe docker-compose file outlines the containers and is a good reference to start.\n\n\nCode\nversion: '3'\nservices:\n  db:\n      build: \"1_ETL/4_postgres/.\"\n      image: \"127.0.0.1:5000/treeful_db:0.0.2\"\n      ports:\n        - \"5432:5432\"\n      secrets:\n        - postgres_pw\n      environment:\n        POSTGRES_DB: treeful-test\n        POSTGRES_PW_FILE: /run/secrets/postgres_pw\n        PGDATA: /var/lib/postgresql/data/pgdata\n      volumes:\n        -\n          type: bind\n          source: ./1_ETL/4_postgres\n          target: /var/lib/postgresql/data\n      deploy:\n        resources:\n            limits:\n              cpus: '4'\n              memory: 8096M\n            reservations:\n              cpus: '2'\n              memory: 1024M\n  frontend:\n    build:\n      context: \"./3_shiny_frontend/\"\n      secrets:\n          - postgres_pw\n          - postgres_host\n    image: \"127.0.0.1:5000/treeful_frontend:0.0.3\"\n    volumes:\n      - ./1_ETL/2_Data/1_output/tree_profiles:/srv/shiny-server/inst/app/tree_profiles\n      - ./1_ETL/2_Data/0_raw_data:/srv/shiny-server/data\n    ports:\n      - \"8080:3838\"\n    secrets:\n      - postgres_pw\n      - postgres_host\n    environment:\n      POSTGRES_DB: treeful-test\n      POSTGRES_PW_FILE: /run/secrets/postgres_pw\n      POSTGRES_HOST_FILE: /run/secrets/postgres_host\n    deploy:\n      resources:\n          limits:\n            cpus: '2'\n            memory: 4096M\n          reservations:\n            cpus: '1'\n            memory: 1024M\n      # restart_policy:\n      #   condition: on-failure\n      #   delay: 5s\n      #   max_attempts: 3\n      #   window: 120s\n\n  # etl:\n  #   # building container to fetch tree dbs and raster data and stick into postgres\n  #   build: 1_ETL/\n  #   image: treeful_etl\n  #   volumes:\n  #     - .:/home/rstudio\n  #   secrets:\n  #     - postgres_pw\n  #     - postgres_host\n  #     - copernicus_key\n  #     - copernicus_uid\n  #     - gbif_email\n  #     - gbif_pw\n  #     - gbif_uid\n  #     - keyring_pw\nsecrets:\n      postgres_pw:\n        file: ./1_ETL/0_secrets/postgres_pw.txt\n      postgres_host:\n        file: ./1_ETL/0_secrets/postgres_host.txt\n      copernicus_key:\n        file: ./1_ETL/0_secrets/copernicus_key.txt\n      copernicus_uid:\n        file: ./1_ETL/0_secrets/copernicus_uid.txt\n      gbif_email:\n        file: ./1_ETL/0_secrets/gbif_email.txt\n      gbif_pw:\n        file: ./1_ETL/0_secrets/gbif_pw.txt\n      gbif_uid:\n        file: ./1_ETL/0_secrets/gbif_uid.txt\n      keyring_pw:\n        file: ./1_ETL/0_secrets/keyring_pw.txt\n\n\n\nETL Container\nThis container runs through the main script, fetching tree location data, getting bioclimatic variables, extracting those from the tree locations and writing everything to Postgis.\n\n\nPostgis Database Container\nAll processed data from the ETL pipeline ends up in here in a few tables. We chose not to write rasters to postgis.\n\n\nShiny Container\nThe actual app runs as docker swarm and connects to the Postgis database."
  },
  {
    "objectID": "index.html#treeful-etl-pipeline-obtaining-and-transforming-tree-occurrence-data",
    "href": "index.html#treeful-etl-pipeline-obtaining-and-transforming-tree-occurrence-data",
    "title": "Treeful Docs",
    "section": "Treeful ETL Pipeline: Obtaining and transforming tree occurrence data",
    "text": "Treeful ETL Pipeline: Obtaining and transforming tree occurrence data\nThis section documents how tree occurrence data is obtained. At the end, we will have our tree locations with the corresponding bioclimatic variables in a postgis database.\n\nGet Climate Projection data & other external datasets\nFirst, we obtain data not included in this repository, namely EU Forest and Copernicus CDS raster files. These downloads will take a while. (Some datasets are neither downloaded, nor included in this repo. They’ve been shared privately with us)\nWe have used Copernicus CMIP5 regional projections, with RPC4.5 and RPC8.5 experiments from the NorESM1-M (NCC, Norway) model. The datasets can be built and obtained here. Our code contains a short helper script for the automated download (set env vars for CDS login before)\n\n\nCode\n#################### Trees4F from figshare ###################\nif (!file.exists(\"2_Data/0_raw_data/EUforestspecies_AMauri.csv\")) {\n  download.file(\"https://springernature.figshare.com/ndownloader/files/6662535\", destfile = \"2_Data/0_raw_data/EUforestspecies_AMauri.csv\")\n}\n\n#################### COPERNICUS CDS Download ###################\n# REGISTER YOURSELF AND ENTER DETAILS FROM HERE:\n# https://cds.climate.copernicus.eu/user/register\n# Beware the user is the UID at the bottom of your user page.\n\nuid <- Sys.getenv(\"COPERNICUS_UID\")\n\nwf_set_key(user=uid, # \n           key=Sys.getenv(\"COPERNICUS_KEY\"), \n           service=\"cds\")\n\nrequest <- list(\n  region = \"europe\",\n  variable = c(\"annual_mean_temperature\", \"annual_precipitation\", \"isothermality\", \"maximum_temperature_of_warmest_month\", \n               \"mean_diurnal_range\", \"mean_temperature_of_coldest_quarter\", \"mean_temperature_of_driest_quarter\", \"mean_temperature_of_warmest_quarter\", \n               \"mean_temperature_of_wettest_quarter\", \"minimum_temperature_of_coldest_month\", \"precipitation_of_coldest_quarter\", \"precipitation_of_driest_month\", \n               \"precipitation_of_driest_quarter\", \"precipitation_of_warmest_quarter\", \"precipitation_of_wettest_month\",\n               \"precipitation_of_wettest_quarter\", \"precipitation_seasonality\", \"temperature_annual_range\", \"temperature_seasonality\", \"volumetric_soil_water\", \"aridity\"),\n  derived_variable = \"annual_mean\",\n  model = \"noresm1_m\",\n  ensemble_member = \"r1i1p1\",\n  experiment = c(\"rcp4_5\", \"rcp8_5\"),\n  statistic = \"mean\",\n  version = \"1.0\",\n  format = \"zip\",\n  dataset_short_name = \"sis-biodiversity-cmip5-regional\",\n  target = \"download.zip\"\n)\n\nncfile <- wf_request(\n  user = uid,\n  request = request,   \n  transfer = TRUE,  \n  path = \"2_Data/0_raw_data/future\",\n  verbose = FALSE\n)\n\n\nrequest <- list(\n  region = \"europe\",\n  origin = \"era5\",\n  variable = c(\"annual_mean_temperature\", \"annual_precipitation\", \"isothermality\", \"maximum_temperature_of_warmest_month\", \"mean_diurnal_range\", \"mean_temperature_of_coldest_quarter\", \"mean_temperature_of_driest_quarter\", \"mean_temperature_of_warmest_quarter\", \"mean_temperature_of_wettest_quarter\", \"minimum_temperature_of_coldest_month\", \"precipitation_of_coldest_quarter\", \"precipitation_of_driest_month\", \"precipitation_of_driest_quarter\", \"precipitation_of_warmest_quarter\", \"precipitation_of_wettest_month\", \n               \"precipitation_of_wettest_quarter\", \"precipitation_seasonality\", \"temperature_annual_range\", \"temperature_seasonality\", \"volumetric_soil_water\"),\n  derived_variable = \"annual_mean\",\n  statistic = \"mean\",\n  version = \"1.0\",\n  format = \"zip\",\n  dataset_short_name = \"sis-biodiversity-era5-regional\",\n  target = \"download.zip\"\n)\n\nncfile <- wf_request(\n  user = uid,\n  request = request,   \n  transfer = TRUE,  \n  path = \"2_Data/0_raw_data/past\",\n  verbose = FALSE\n)\n\n\nif (file.exists(\"2_Data/0_raw_data/past/download.zip\")) {\n  utils::unzip(\"2_Data/0_raw_data/past/download.zip\", exdir = \"2_Data/0_raw_data/past/\")\n  file.remove(\"2_Data/0_raw_data/past/download.zip\")\n}\nif (file.exists(\"2_Data/0_raw_data/future/download.zip\")) {\n  utils::unzip(\"2_Data/0_raw_data/future/download.zip\", exdir = \"2_Data/0_raw_data/future/\")\n  file.remove(\"2_Data/0_raw_data/future/download.zip\")\n}\n\n\n\n\nGetting Tree Location Data\nTo produce reliable climate envelopes we would like to obtain as many trees from various biogeographical regions of Europe. This section details how we process them and produces a database with these occurrences:\n\n\n\nTree occurences in treeful per source database\n\n\n\n\n\n\n\n\nNote\n\n\n\nWe are not doing any sampling on tree occurrences. This means that small areas with many tree records will produce a higher density in the climate envelopes. In the current state of our app and plots, this does reflect to the user.\n\n\n\nAcademic data sources\nWe used the TRY plant trait database and EU Forest. Both contain tree locations and botanical names. Both are academic, high-quality datasets with extensive data cleaning in place. We used EU Forest to generate our master list of botanical names. These trees will subsequently be used. A simple fuzzy matching is used to ensure Sorbus Torminalis and Sorbus-torminalis are matched as Sorbus torminalis (We used a conservative string dist=1).\n\n\nCode\n############ Load Packages ############ \nif(!require(librarian)) install.packages(\"librarian\")\nlibrary(librarian)\nshelf(data.table,stringr,stringdist,fuzzyjoin,dplyr)\n\n############ Define Function for fuzzy matching ############ \nflatten_names <- function(tree_name) {\n  tree_name <-  str_replace_all(tree_name,\" \", \"\") %>%\n    str_replace_all(.,\"\\\\.\",\"\") %>%\n    str_replace_all(.,\"\\\\-\",\"\") %>%\n    str_replace_all(.,\"\\\\'\",\"\") %>%\n    tolower(.)\n}\n\n\nget_fuzzy_plant_names <- function(plant_database, master_list, max_string_dist=3){\n# Prepare for matching\n# Extract unique names\ndatabase_names <- plant_database[,.(latin_name=unique(latin_name))]\n\n# Flatten names\nmaster_list[,flat_name:=flatten_names(latin_name)]\ndatabase_names[,flat_name:=flatten_names(latin_name)]\n\n# Match\nstringdist <- as.data.table(\n                stringdist_join(database_names, master_list, \n                by = c(\"flat_name\" = \"flat_name\"), \n                mode = \"inner\", \n                method = \"dl\", \n                max_dist = max_string_dist, \n                distance_col = \"dist\"))\n# Clean matching\nstringdist <- stringdist[,.(data_set_name=latin_name.x,master_list_name=latin_name.y,distance=dist)]\nstringdist <- setorder(stringdist,-distance)\nreturn(stringdist)\n# As an example of possible other matching functions:\n# amatch <-  amatch(database_names[,flat_name], master_list[,flat_name], maxDist = 0.1)\n}\n############ MAIN: Create master list of botanical names ############ \n# Load datasets\n# Use trees4EU as master list, more coverage\nmaster_list <- data.table::fread(\"2_Data/0_raw_data/EUforestspecies_AMauri.csv\") %>% \n  janitor::clean_names() %>% \n  dplyr::select(latin_name = species_name) %>% \n  distinct()\nmaster_list <- na.omit(master_list)\n\n############ OPEN TREES DATA BASE ############ \n# Load and prepare database\n\n# Load database\nopen_trees_db <- fread(\"2_Data/1_output/all_merged.csv\")\nsetnames(open_trees_db,\"species\",\"latin_name\")\nopen_trees_db <- na.omit(open_trees_db)\n\n# Match db names\nmax_string_dist = 1 \nopen_trees_matching_table<- get_fuzzy_plant_names(open_trees_db, master_list, max_string_dist)\nopen_trees_matching_table_selection <- open_trees_matching_table[distance<=1,]\n# Filter database\nopen_trees_db_selection <- open_trees_db[open_trees_matching_table_selection[,.(data_set_name,master_list_name)], on = c(latin_name = \"data_set_name\"), nomatch = NULL]\n# open_trees_db_selection2 <- open_trees_db[latin_name %in% open_trees_matching_table_selection[,data_set_name]]\n\n############ TRY DATA BASE ############ \n# Load database\nif (file.exists(\"2_Data/0_raw_data/tree_georef_3.txt\")) {\n  try_trees <- data.table::fread(\"2_Data/0_raw_data/tree_georef_3.txt\") %>% \n    janitor::clean_names()\n  \n  setnames(try_trees,\"acc_species_name\",\"latin_name\")\n  try_trees <- na.omit(try_trees)\n  \n  \n  # Match db names\n  max_string_dist = 1 \n  try_trees_matching_table<- get_fuzzy_plant_names(try_trees, master_list, max_string_dist)\n  try_trees_matching_table_selection <- try_trees_matching_table[distance<=1,]\n  # Filter database\n  try_trees_selection <- try_trees[try_trees_matching_table_selection[,.(data_set_name,master_list_name)], on = c(latin_name = \"data_set_name\"), nomatch = NULL]\n  # open_trees_db_selection2 <- open_trees_db[latin_name %in% open_trees_matching_table_selection[,data_set_name]]\n  \n  \n} else {\n  try_trees_selection <- tibble(master_list_name = character(), \n                                tree_georef_1_std_value = numeric(),\n                                obs_data_std_value = numeric())\n}\n\n\n############ Trees4F DATA BASE ############ \n# Load and prepare database\n\n# Load database\ntrees4f_db <- data.table::fread(\"2_Data/0_raw_data/EUforestspecies_AMauri.csv\") %>% \n  janitor::clean_names()\n\nsetnames(trees4f_db,\"species_name\",\"latin_name\")\ntrees4f_db <- na.omit(trees4f_db)\n\n# Match db names\nmax_string_dist = 3 \ntrees4f_db_matching_table<- get_fuzzy_plant_names(trees4f_db, master_list, max_string_dist)\ntrees4f_db_matching_table_selection <- trees4f_db_matching_table[distance<=1,]\n# Filter database\ntrees4f_db_selection <- trees4f_db[trees4f_db_matching_table_selection[,.(data_set_name,master_list_name)], on = c(latin_name = \"data_set_name\"), nomatch = NULL]\n# open_trees_db_selection2 <- open_trees_db[latin_name %in% open_trees_matching_table_selection[,data_set_name]]\n\n\n\n\n# enhance master list with GBIF taxo IDs and write master list to file\ntree_master_list <- master_list %>% \n  mutate(gbif_taxo_id = name_backbone_checklist(name=.$latin_name)$usageKey) %>% \n  # remove  unmatched or genus level taxo matches\n  filter(str_length(gbif_taxo_id) > 5 & !is.na(gbif_taxo_id))\n\nfwrite(tree_master_list,\"2_Data/1_output/eu_native_trees_master.csv\")\ntree_master_list <- fread(\"2_Data/1_output/eu_native_trees_master.csv\") \n\n\nrm(open_trees_db, open_trees_matching_table, open_trees_matching_table_selection, try_trees, try_trees_matching_table, \n   try_trees_matching_table_selection, trees4f_db, trees4f_db_matching_table, trees4f_db_matching_table_selection\n   )\n\n#EOF\n\n\nWe finish this file with rgbif::name_backbone_checklist() where we obtain the GBIF taxo ID for each botanical name. This is part of our master data list.\n\n\nEuropean Tree Cadastres\nWe wanted to include the proliferating corpus of tree cadastres of European cities. We collected two dozen or so data sources into this file. Since they’re all unharmonized, extensive data cleaning happens here (we did not deal with CRS transformations but only kept datasets with EPSG:4326):\n\n\nCode\n#############\n# This script will load various tree location data into one. \n# Goal: have all in one db with harmonized botanical species name, X and Y coordinate in EPSG 4326\n\n\ntree_dbs <- read_xlsx(\"2_Data/0_raw_data/opendata_trees.xlsx\") %>% \n  janitor::clean_names() %>% \n  filter(suitable == \"y\" & epsg == \"4326\") %>% \n  mutate(location = janitor::make_clean_names(location)) %>% \n  mutate(botanical_col = tolower(botanical_col)) \n  # mutate(lon_col = janitor::make_clean_names(lon_col)) %>% \n  # mutate(lat_col = janitor::make_clean_names(lat_col)) \n\n\ntree_dbs <- data.table(tree_dbs)\nfor (i in tree_dbs[,file_name]) {\n  utils::unzip(zipfile=paste(\"2_Data/0_raw_data/tree_cadastres/zip/\",i,\".zip\",sep=\"\"))\n}\n\nfor (i in 1:nrow(tree_dbs)) {\n\n  ifelse(str_detect(tree_dbs$file_name[i], \"csv\"),\n         assign(tolower(tree_dbs$location[i]),\n                janitor::clean_names(read_delim(paste0(\"2_Data/0_raw_data/tree_cadastres/\", tree_dbs$file_name[i])))),\n         assign(tolower(tree_dbs$location[i]),\n                janitor::clean_names(bind_cols(jsonlite::read_json(paste0(\"2_Data/0_raw_data/tree_cadastres/\", tree_dbs$file_name[i]), simplifyVector = TRUE)$features$properties,\n                                     jsonlite::read_json(paste0(\"2_Data/0_raw_data/tree_cadastres/\", tree_dbs$file_name[i]), simplifyVector = TRUE)$features$geometry)\n                                     )\n                )\n  )\n  print(i)\n}\n\n\n\n# # Compress all the csv files with gzip\n# tree_dbs <- data.table(tree_dbs)\n# for (i in tree_dbs[,file_name]) {\n#      db <- fread(paste(\"2_Data/0_raw_data/tree_cadastres/\",i,sep=\"\"))\n#      fwrite(db,paste(\"2_Data/0_raw_data/tree_cadastres/\",i,\".gz\",sep=\"\"),compress=\"gzip\")\n# }\n\n# tree_dbs[,file_name:=paste(file_name,\".gz\",sep=\"\")]\n# write.xlsx2(tree_dbs, \"2_Data/0_raw_data/opendata_trees.xlsx\", sheetName = \"Sheet1\", \n#             col.names = TRUE, row.names = TRUE, append = FALSE)\n\n# \n# tree_dbs <- data.table(tree_dbs)\n# for (i in tree_dbs[,location]) {\n#     print(i)\n#     assign(tolower(i), paste(fread(paste(\"2_Data/0_raw_data/tree_cadastres/\",tree_dbs[location==i,file_name],sep=\"\"))))\n# }\n              \n# too small data to automate. manually merge mutate\n#split_species <- filter(tree_dbs, str_detect(botanical_col, \"\\\\+\"))\n#mutate(tourcoing, merged_species = paste0(genre, \" \", espece)) %>% write_csv(file = \"data/opentrees/tourcoing.csv\")\n\nmerged_geo <- filter(tree_dbs, lon_col == lat_col)\nsep_geo <- filter(tree_dbs, lon_col != lat_col)\n\n\n#######\n# unmerge merged geographies\nfor (i in 1:nrow(merged_geo)) {\n  temp_db <- get(tolower(merged_geo$location[i]), envir = globalenv()) %>% \n    dplyr::select(matches(paste0(merged_geo$botanical_col[i], \"|\", merged_geo$lon_col[i]), ignore.case = TRUE)) \n  \n  temp_db <- temp_db %>% \n    separate(merged_geo$lon_col[i], into = c(\"x\", \"y\"), sep = \",\") %>% \n    mutate(x = str_remove(x, \"c\\\\(\"), y = str_remove(y, \"\\\\)\")) %>% \n    rename(species = merged_geo$botanical_col[i])\n  \n  assign(tolower(merged_geo$location[i]), temp_db)\n  print(i)\n  print(merged_geo$location[i])\n}\n\n# treat regular lat lon sources\nfor (i in 1:nrow(sep_geo)) {\n  temp_db <- get(tolower(sep_geo$location[i]), envir = globalenv()) %>% \n    dplyr::select(matches(paste0(sep_geo$botanical_col[i], \"|\", sep_geo$lon_col[i], \"|\", sep_geo$lat_col[i]), ignore.case = TRUE))\n  \n  temp_db <- temp_db %>% \n    rename(species = sep_geo$botanical_col[i], \n           x = sep_geo$lat_col[i],\n           y = sep_geo$lon_col[i]\n           )\n  \n  assign(tolower(sep_geo$location[i]), temp_db)\n  print(i)\n  print(sep_geo$location[i])\n}\n\n#bring it all together into one df\nall_trees <- tibble()\n\nfor (i in 1:nrow(tree_dbs)) {\n  temp_db <- get(tolower(tree_dbs$location[i]), envir = globalenv()) %>% \n    dplyr::select(x, y, species)\n  \n  temp_db <- temp_db %>% \n    mutate(x = as.numeric(x)) %>% \n    mutate(y = as.numeric(y)) %>% \n    mutate(db_city_origin = tree_dbs$location[i])\n  \n  assign(tolower(tree_dbs$location[i]), temp_db)\n  all_trees <- bind_rows(all_trees, temp_db)\n  print(i)\n  print(tree_dbs$location[i])\n}\n\nall_trees_centroids <- all_trees %>% \n  st_as_sf(coords = c(\"y\", \"x\"), na.fail = F) %>% \n  group_by(db_city_origin) %>% \n  summarise(st_union(geometry)) %>%\n  st_centroid() \n\n#### save it all on disk, 4 million trees\nwrite_csv(all_trees, \"2_Data/1_output/all_merged.csv\")\n\n\n#\"specie|especi|nom_lat|latboomsoort|espece|\n#nom_cientific|wetenschappelijke_naam|classe|dendro_taxon_tid|\n#  nome_scien|traeart|SPECIE|sortiment|essence_scient|gattung_lat|species|gattung|geo_point\"\n\n# all tree lists saved as csv in data folder. why csv?\n# cause majority of opendata portal tree lists were in csv so its least cumbersome conversion\n# also csv means less characters and therefore less data when things become very large. \n\n\nThis writes a file with only botanical name, X, Y and source database for the next step.\n\n\nGBIF\nThe largest amount of our tree data comes from GBIF. We simply query a bounding box of Europe for all species from our master list, enriched already with GBIF taxo IDs. You could re-generate the dataset with most recently added tree occurrences with this (GBIF takes a while to prepare the dataset and you need to have your env variables GBIF_EMAIL, GBIF_PWD, GBIF_USER configured):\n\ngbif_download <- occ_download(\n    pred_in(\"taxonKey\", tree_master_list$gbif_taxo_id),\n    #pred(\"taxonKey\", 5284884),\n    # this is the bounding box of europe\n    pred_within(\"POLYGON((-15 75,-15 30,40 30,40 75,-15 75))\"),\n    pred_lt(\"coordinateUncertaintyInMeters\",1000), #downstream processing needs 1km accuracy\n    pred(\"hasCoordinate\", TRUE),\n    pred(\"hasGeospatialIssue\", FALSE), # remove GBIF default geospatial issues\n    pred(\"occurrenceStatus\",\"PRESENT\"),\n    pred_gte(\"year\", 1960), #only keep trees seen after 1960\n    format = \"SIMPLE_CSV\")\n  #\n   occ_download_wait(gbif_download)\n\n\n\n\nGetting Bioclimatic Variables\nWe tested CHELSA, worldclim and Copernicus CDS to get bioclimatic variables. We prefer Copernicus for their extensive documentation and the convenient time frame of past bioclimatic data, from 1979-2018. This is where we expect the largest overlap with the life span of our trees from the occurrence dataset.\nOur functions getpastclimate() and getfutureclimate() can theoretically be used to switch bioclimatic data sources but we have not implemented those. These functions are used to read our Copernicus raster files.\n\n\nReading Climate Rasters into R\nIn order to extract bioclimatic variables from each species location, we’ll have to load raster files into R. The function described here will solve a few complexities:\n\nWe convert raster values into units fit for anlysis.\nStacked rasters need to be treated accordingly.\nEfficiency matters greatly here, especially when it comes to RAM-efficient raster reading.\n\nWhat could and probably should not be done here: CRS-reprojections. Sometimes you may get a different CRS. Reproject outside of your ETL pipeline and then read.\n\n\nCode\n##################### Function to Get  climate Rasters ##################\n# In theory they can easily be adjusted to other climate raster providers. For some, snippets exist in the functions already but probably wont work \n# in the entire workflow of treeful. All processing here is only tested with Copernicus\n# you pass a provider and a bioclimatic var like bio01 or bio13 to the function and it returns one raster. you can stack them later on. \n\n\ngetpastclimate <- function(source = \"copernicus\", bioclim = \"bio01\") {\n  if (source == \"climateeu\") {\n    bio_path <- case_when(bioclim == \"bio01\" ~ \"MAT\",\n                          bioclim == \"bio12\" ~ \"MAP\",\n                          )\n    \n    bio_raster <- raster(paste0(\"data/climateEU/Normal_1961-1990_bioclim/\", bio_path, \".asc\"))\n\n    raster::crs(bio_raster) <- \"+proj=aea +lat_0=30 +lon_0=10 +lat_1=43 +lat_2=62 +x_0=0 +y_0=0 +ellps=intl +units=m +no_defs +type=crs\"\n    \n    bio_raster <- raster::projectRaster(bio_raster, crs = 4326)\n    \n  }\n  \n  if (source == \"copernicus\") {\n    # Get bioclimate data from copernicus. Download bioclimate file with login at https://cds.climate.copernicus.eu/\n    \n    bio_path <- toupper(bioclim)\n\n    bio_raster <- terra::rast(paste0(\"2_Data/0_raw_data/past/\", bio_path, \"_era5-to-1km_1979-2018-mean_v1.0.nc\"))\n    # convert bioclim as per copernicus documentation. for some reasone case_when does not work here.     \n    if (bioclim %in% c(\"bio01\", \"bio05\", \"bio06\", \"bio08\", \"bio09\", \"bio10\", \"bio11\")) \n    {bio_raster <- bio_raster - 273.15\n    } else if (bioclim == \"bio12\") {bio_raster <- bio_raster*3600*24*365*1000\n    } else if (bioclim %in% c(\"bio13\", \"bio14\")) {bio_raster <- bio_raster*3600*24*30.5*1000\n    } else if (bioclim %in% c(\"bio16\", \"bio17\", \"bio18\", \"bio19\")) {bio_raster <- bio_raster*3600*24*91.3*1000\n    }\n    # a bit unclear if bio13-bio19 can and should also be comverted like bio12. probably not as theyre not on annual reference period\n\n    \n  }\n  # worldclim would be great cause it fetches all 19 bioclimatic at once. and has a great time range from 1970-2000. \n  # but units of each var are stange. \n\n  if (source == \"worldclim\") {\n    \n    bio_path <- case_when(bioclim == \"bio01\" ~ \"bio_1\",\n                          bioclim == \"bio02\" ~ \"bio_2\",\n                          bioclim == \"bio03\" ~ \"bio_3\",\n                          bioclim == \"bio04\" ~ \"bio_4\",\n                          bioclim == \"bio05\" ~ \"bio_5\",\n                          bioclim == \"bio06\" ~ \"bio_6\",\n                          bioclim == \"bio07\" ~ \"bio_7\",\n                          bioclim == \"bio08\" ~ \"bio_8\",\n                          bioclim == \"bio09\" ~ \"bio_9\",\n                          bioclim == \"bio10\" ~ \"bio_10\",\n                          bioclim == \"bio11\" ~ \"bio_11\",\n                          bioclim == \"bio12\" ~ \"bio_12\",\n                          bioclim == \"bio13\" ~ \"bio_13\",\n                          bioclim == \"bio14\" ~ \"bio_14\",\n                          bioclim == \"bio15\" ~ \"bio_15\",\n                          bioclim == \"bio16\" ~ \"bio_16\",\n                          bioclim == \"bio17\" ~ \"bio_17\",\n                          bioclim == \"bio18\" ~ \"bio_18\",\n                          bioclim == \"bio19\" ~ \"bio_19\"\n    )\n    \n    bio_raster <- raster(paste0(\"2_Data/1_output/worldclim_cropped/wc2.1_30s_\", bio_path, \".tif\"))\n    \n\n  }\n  \n  if (source == \"chelsa\") {\n    \n    bio_path <- case_when(bioclim == \"bio01\" ~ \"bio1\",\n                          bioclim == \"bio12\" ~ \"bio12\"\n    )\n    \n    bio_raster <- raster(paste0(\"2_Data/1_output/CHELSA_cropped/CHELSA_\", bio_path, \"_1981-2010_V.2.1.tif\"))\n    \n    if (bioclim == \"bio01\") {bio_raster <- raster::calc(bio_raster, function(x) { x / 10 - 273.15 })\n    } else if (bioclim == \"bio12\") {\n      bio_raster <- raster::calc(bio_raster, function(x) { x / 10})\n    }\n    \n    \n  }\n  \n  \n  return(bio_raster)\n  rm(bio_raster)\n  \n}\n\n\ngetsoilproperties <- function(variable = \"STU_EU_DEPTH_ROOTS\") {\n  soil_layer <- terra::rast(paste0(\"2_Data/0_raw_data/soil/\", variable, \"_4326.tif\"))\n  return(soil_layer)\n  rm(soil_layer)\n}\n\n\n\n\nMerging Tree Locations and Bioclimatic Variables\nWe now have millions of tree locations and rasters of past bioclimatic variables. We extract each bioclimatic variable for each tree location. For that, we first merge all tree data sources into a large simple feature object.\n\n\nCode\n#################### LOad DBs, merge, turn into SF, extract bioclim #############################\n\nif (!file.exists(\"2_Data/1_output/tree_db.csv\")) {\n  \n  ######################## turn name-matched data.tables into SF ###################\n  trees4f_sf <- trees4f_db_selection %>% \n    sf::st_as_sf(coords = c(\"x\", \"y\"), crs = 3035) %>% \n    sf::st_transform(crs = 4326) %>% \n    mutate(db = \"trees4f\")\n  \n  open_trees_sf <- open_trees_db_selection %>% \n    filter(!is.na(x) & !is.na(y)) %>% \n    st_as_sf(coords = c(\"y\", \"x\"), crs = 4326) %>% \n    mutate(db = \"cadastres\")\n  \n  try_trees_sf <- try_trees_selection %>% \n    filter(!is.na(tree_georef_1_std_value) & !is.na(obs_data_std_value)) %>% \n    st_as_sf(coords = c(\"obs_data_std_value\", \"tree_georef_1_std_value\"), crs = 4326) %>% \n    mutate(db = \"try\")\n  \n  gbif_trees_sf <- gbif_trees %>% \n    dplyr::select(taxonkey, x = decimallatitude, y = decimallongitude) %>% \n    left_join(dplyr::select(tree_master_list, master_list_name = latin_name, gbif_taxo_id), by = c(\"taxonkey\" = \"gbif_taxo_id\")) %>% \n    filter(!is.na(x) & !is.na(y) & !is.na(master_list_name)) %>% \n    st_as_sf(coords = c(\"y\", \"x\"), crs = 4326) %>% \n    mutate(db = \"gbif\")\n  \n  sendstatus(\"got all dbs and turned them into sf\")\n  rm(gbif_trees, trees4f_db_selection, open_trees_db_selection, try_trees_selection)\n  ######################## bind all three sources into one ####################################\n  \n  tree_dbs <- rbind(\n    as.data.table(trees4f_sf)[, .(master_list_name, db, geometry)],\n    as.data.table(open_trees_sf)[, .(master_list_name, db, geometry)],\n    as.data.table(try_trees_sf)[, .(master_list_name, db, geometry)],\n    as.data.table(gbif_trees_sf)[, .(master_list_name, db, geometry)]\n  )\n  \n  rm(gbif_trees_sf, open_trees_sf, try_trees_sf, trees4f_sf, try_species)\n  gc()\n  \n  ######################### The heart of it all: getting bioclimatic vars for each tree ##########\n  sendstatus(paste0(\"Cutting down tree db to species with n>1500, currently at \", nrow(tree_dbs)))\n  \n  tree_count <- tree_dbs %>% \n    group_by(master_list_name) %>% \n    summarise(n=n()) %>% \n    filter(n>1500)\n  \n  tree_dbs <- tree_dbs %>% \n    filter(master_list_name %in% tree_count$master_list_name)\n  gc()\n  \n  sendstatus(paste0(\"Cut small species occurrences. Starting extraction for \", nrow(tree_dbs), \" tree occurrences\"))\n  \n  tree_dbs <- tree_dbs %>% \n    st_as_sf(crs = 4326)\n  \n  bioclim_stack <- c(\n    getpastclimate(source = \"copernicus\", bioclim = \"bio01\"),\n    getpastclimate(source = \"copernicus\", bioclim = \"bio02\"),\n    getpastclimate(source = \"copernicus\", bioclim = \"bio03\"),\n    getpastclimate(source = \"copernicus\", bioclim = \"bio04\"),\n    getpastclimate(source = \"copernicus\", bioclim = \"bio05\"),\n    getpastclimate(source = \"copernicus\", bioclim = \"bio06\"),\n    getpastclimate(source = \"copernicus\", bioclim = \"bio07\"),\n    getpastclimate(source = \"copernicus\", bioclim = \"bio08\"),\n    getpastclimate(source = \"copernicus\", bioclim = \"bio09\"),\n    getpastclimate(source = \"copernicus\", bioclim = \"bio10\"),\n    getpastclimate(source = \"copernicus\", bioclim = \"bio11\"),\n    getpastclimate(source = \"copernicus\", bioclim = \"bio12\"),\n    getpastclimate(source = \"copernicus\", bioclim = \"bio13\"),\n    getpastclimate(source = \"copernicus\", bioclim = \"bio14\"),\n    getpastclimate(source = \"copernicus\", bioclim = \"bio15\"),\n    getpastclimate(source = \"copernicus\", bioclim = \"bio16\"),\n    getpastclimate(source = \"copernicus\", bioclim = \"bio17\"),\n    getpastclimate(source = \"copernicus\", bioclim = \"bio18\"),\n    getpastclimate(source = \"copernicus\", bioclim = \"bio19\")\n  )\n  sendstatus(\"read and stacked bioclim rasters. starting bioclim extraction\")\n  \n  tree_dbs <- tree_dbs %>% \n    mutate(terra::extract(bioclim_stack, ., ID = F)) \n  \n  rm(bioclim_stack)\n  gc()\n  \n  ##### soil data extraction begin\n  soil_stack <- c(getsoilproperties(\"STU_EU_DEPTH_ROOTS\"),\n                  getsoilproperties(\"STU_EU_T_CLAY\"),\n                  getsoilproperties(\"STU_EU_S_CLAY\"),\n                  getsoilproperties(\"STU_EU_T_SAND\"),\n                  getsoilproperties(\"STU_EU_S_SAND\"),\n                  getsoilproperties(\"STU_EU_T_SILT\"),\n                  getsoilproperties(\"STU_EU_S_SILT\"),\n                  getsoilproperties(\"STU_EU_T_OC\"),\n                  getsoilproperties(\"STU_EU_S_OC\"),\n                  getsoilproperties(\"STU_EU_T_BD\"),\n                  getsoilproperties(\"STU_EU_S_BD\"),\n                  getsoilproperties(\"STU_EU_T_GRAVEL\"),\n                  getsoilproperties(\"STU_EU_S_GRAVEL\"),\n                  getsoilproperties(\"SMU_EU_T_TAWC\"),\n                  getsoilproperties(\"SMU_EU_S_TAWC\"),\n                  getsoilproperties(\"STU_EU_T_TAWC\"),\n                  getsoilproperties(\"STU_EU_S_TAWC\"))\n  sendstatus(\"read and stacked soil rasters. starting soil extraction\")\n  tree_dbs <- tree_dbs %>% \n    mutate(terra::extract(soil_stack, ., ID = F)) %>% \n    mutate(across(.cols = starts_with(c(\"BIO\", \"STU\", \"SMU\")), ~ round(.x, digits = 2), .names = \"{.col}\"))\n  \n  rm(soil_stack)\n  gc()\n  \n  # tree_dbs <- tree_dbs %>% \n  #   st_drop_geometry()\n  ################################ write it all to csv #################################\n  sendstatus(\"saving DB to disk\")\n  data.table::fwrite(x = tree_dbs, file = \"2_Data/1_output/tree_db.csv\")\n} else {\n  sendstatus(\"tree db exists, reading from disk/n\")\n  tree_dbs <- fread(\"2_Data/1_output/tree_db.csv\")\n}\n\ncon <- backend_con()\n\nif (!RPostgres::dbExistsTable(conn = con, name = \"tree_dbs\")) {\n  # writing trees to postgres DB\n  sendstatus(\"writing tree db to postgres\")\n  con <- backend_con()\n  \n  sf::st_write(tree_dbs, dsn = con, table = \"tree_dbs\",\n               append = FALSE)\n}\n\n\ntree_db_sample_size <- group_by(tree_dbs, master_list_name) %>% \n  summarise(n=n())\n\ntree_master_list <- fread(\"2_Data/1_output/eu_native_trees_master.csv\") %>% \n  left_join(tree_db_sample_size, by = c(\"latin_name\" = \"master_list_name\")) %>% \n  filter(n>1500)\n\nsendstatus(paste0(\"Had \", nrow(tree_db_sample_size), \" species, now down to \", nrow(tree_master_list)))\n\nfwrite(tree_master_list, \"2_Data/1_output/eu_native_trees_master.csv\")\n\nrm(tree_db_sample_size, tree_master_list)\ngc()\n\nDBI::dbDisconnect(conn = con)\n\n##### EOF ####\n\n\nWhat we found to work fastest and least memory intensive is stacking all rasters first and then running terra::extract()\n\n  bioclim_stack <- c(\n    getpastclimate(source = \"copernicus\", bioclim = \"bio01\"),\n    getpastclimate(source = \"copernicus\", bioclim = \"bio02\")\n    ######## etc #####\n    ######## etc #####\n  )\n  \n  tree_dbs <- tree_dbs %>% \n    mutate(terra::extract(bioclim_stack, ., ID = F)) \n\n\n\nEnrich Species Master Table\nThis section explains how to make your species distribution data more user friendly. For a specialist audience, you may be able to expose simply botanical names. Here we’re adding descriptions and images for species with a simple wikipedia scraper.\n\n\nCode\nlibrary(librarian)\nshelf(rvest)\n# load list with botanical names and taxonomy IDs\ntree_master_list <- fread(\"2_Data/1_output/eu_native_trees_master.csv\")\n\n# a simple function to search wikipedia for botanical names\nwikipedia <- function(search_terms, lang = c(\"en\", \"de\", \"es\", \"fr\")) {\n    # if system language contains \"en\" use English Wikipedia version\n    if (grepl(\"en\", lang)) {\n      return(paste0(\"https://en.wikipedia.org/w/index.php?search=\", URLencode(search_terms)))\n    }\n    \n    # if system language contains \"de\" use German Wikipedia version\n    else if (grepl(\"de\", lang)) {\n      return(paste0(\"https://de.wikipedia.org/w/index.php?search=\", URLencode(search_terms)))\n    }\n    \n    \n    # if \"lang\" is not specified and default system language is not\n    # English, German, Spanish or French, use the English version\n    else {\n      return(paste0(\"https://en.wikipedia.org/w/index.php?search=\", URLencode(search_terms)))\n    }\n  }\n\n# scrape wikipedia for first paragraph and image\nfor (i in 1:nrow(tree_master_list)) {\n  tree_url <- wikipedia(tree_master_list$latin_name[i], \"de\")\n  tree_page <-  tree_url %>% \n    rvest::read_html()\n  \n  tree_tribble <- tibble::tribble(~descr_de, ~url, ~image_url,\n                  rvest::html_text(rvest::html_element(tree_page, xpath = \"/html/body/div[3]/div[3]/div[5]/div[1]/p[1]\"), trim = TRUE),\n                  tree_url,\n                  rvest::html_attr(html_element(tree_page, xpath = \"/html/body/div[3]/div[3]/div[5]/div[1]/table[1]/tbody/tr[2]/td/span/a/img\"), \"src\")\n                  ) \n  tree_master_list$descr_de[i] <- tree_tribble$descr_de\n  tree_master_list$url[i] <- tree_tribble$url\n  tree_master_list$image_url[i] <- tree_tribble$image_url\n  cat(\"fetched \", tree_tribble$descr_de, \" \\n for \", tree_master_list$latin_name[i])\n  # be kind to wikipedia\n  Sys.sleep(1.2)\n}\n\ntree_master_list <- tree_master_list %>% \n  mutate(image_url = stringr::str_remove(image_url, \"^\\\\/\\\\/\"))\n\nsendstatus(\"writing master list with drescriptions to postgres\")\n\nfwrite(tree_master_list, \"2_Data/1_output/eu_native_trees_master.csv\")\ncon <- backend_con()\nRPostgres::dbWriteTable(con, \"tree_master_list\", tree_master_list, overwrite = TRUE)\n\nDBI::dbDisconnect(conn = con)\n\n\n\n\nCalculate Percentile Ranges from Mean\nWe have used the sampled and well documented dataset EU Forest to calculate percentiles ranges. Bioclimatic variables of tree occurrence do not yield a normal distribution, hence we are calculating the distance from mean for each species and variable. The Eu Forest dataset is sampled and contains enough occurrences, while occurrences from crowd-sourced efforts (such as GBIF) are more prone to distorted data (showing where trees have been mapped rather than where trees occur). We have used a cutoff of n>200 occurrences from EU Forest As per this source. Below are histograms for a few sample biclimatic variables: Annual BIO01 (Mean Temperature), BIO5 (Max Temperature of Warmest Month), BIO6 (Min Temperature of Coldest Month), BIO8 (Mean Temperature of Wettest Quarter), BIO9 (Mean Temperature of Driest Quarter), BIO12 (Annual Precipitation), BIO13 (Precipitation of Wettest Month), BIO14 (Precipitation of Driest Month)\n\n\nBIO01BIO05BIO12BIO13BIO14\n\n\n\n\n\nHistogram of BIO01 of tree occurences\n\n\n\n\n\n\n\nHistogram of BIO05 of tree occurences\n\n\n\n\n\n\n\nHistogram of BIO12 of tree occurences\n\n\n\n\n\n\n\nHistogram of BIO13 of tree occurences\n\n\n\n\n\n\n\nHistogram of BIO14 of tree occurences\n\n\n\n\n\n\n\n\nMake Raster data available to Shiny App\nTables created in this ETL pipeline are written to a PostGIS DB. To make raster files available to shiny you have two (actually more like one) options:\n\nOption 1: Writing Raster files to PostGIS DB\nThe bioclimatic and soil rasters used in this project are several GBs large and usually do not fit into memory. This snipped reads them as raster stack, writes the stack to the PostGIS DB and removes it.\n\n\n\n\n\n\nWarning\n\n\n\nThis section relies on the package rpostgis. Currently, there’s no simple other way to write raster data to postGIS from R, neither sf nor terra nor stars. See this discussion. We therefore switched to the approach below: the Shiny app reads values directly from raster files on disk. Slightly less performant for our use case.\n\n\n\n\nCode\nprint(\"large data transfer out starting. Writing all Rasters as rasterstack to Postgres. WE DO NOT RECOMMEND THIS APPROACH\")\n\ncon <- backend_con()\n\n# \n# pastbio01 <- getpastclimate(source = \"copernicus\", bioclim = \"bio01\")\n# \n# \n# pastbio12 <- getpastclimate(source = \"copernicus\", bioclim = \"bio12\")\n# crs(pastbio12) <- \"+proj=longlat +datum=WGS84 +no_defs +type=crs\"\n# # we set this proj here and it seems to stick to R raster object. \n# # when writing into postgis, there SRID appears to be 3395\n\n########################## Past Raster ############################\nif (!RPostgres::dbExistsTable(conn = con, name = \"past\")) {\n  sendstatus(\"Reading in Copernicus past raster\")\n  past <- raster::stack(raster::raster(getpastclimate(source = \"copernicus\", bioclim = \"bio01\")),\n                        raster::raster(getpastclimate(source = \"copernicus\", bioclim = \"bio02\")),\n                        raster::raster(getpastclimate(source = \"copernicus\", bioclim = \"bio03\")),\n                        raster::raster(getpastclimate(source = \"copernicus\", bioclim = \"bio04\")),\n                        raster::raster(getpastclimate(source = \"copernicus\", bioclim = \"bio05\")),\n                        raster::raster(getpastclimate(source = \"copernicus\", bioclim = \"bio06\")),\n                        raster::raster(getpastclimate(source = \"copernicus\", bioclim = \"bio07\")),\n                        raster::raster(getpastclimate(source = \"copernicus\", bioclim = \"bio08\")),\n                        raster::raster(getpastclimate(source = \"copernicus\", bioclim = \"bio09\")),\n                        raster::raster(getpastclimate(source = \"copernicus\", bioclim = \"bio10\")),\n                        raster::raster(getpastclimate(source = \"copernicus\", bioclim = \"bio11\")),\n                        raster::raster(getpastclimate(source = \"copernicus\", bioclim = \"bio12\")),\n                        raster::raster(getpastclimate(source = \"copernicus\", bioclim = \"bio13\")),\n                        raster::raster(getpastclimate(source = \"copernicus\", bioclim = \"bio14\")),\n                        raster::raster(getpastclimate(source = \"copernicus\", bioclim = \"bio15\")),\n                        raster::raster(getpastclimate(source = \"copernicus\", bioclim = \"bio16\")),\n                        raster::raster(getpastclimate(source = \"copernicus\", bioclim = \"bio17\")),\n                        raster::raster(getpastclimate(source = \"copernicus\", bioclim = \"bio18\")),\n                        raster::raster(getpastclimate(source = \"copernicus\", bioclim = \"bio19\"))\n  )\n  sendstatus(\"Writing Copernicus Past to DB\")\n  rpostgis::pgWriteRast(con,\n                        name = \"past\", raster = past, overwrite = TRUE\n  )\n  rm(past)\n  gc()\n  } else {\n    cat(\"Raster layers exist in Postgres. Skipping. \")\n  }\n  \n########################## Future 2050 4.5 Raster ############################\nif (!RPostgres::dbExistsTable(conn = con, name = \"future_2050_4_5\")) {\n  sendstatus(\"starting with reading Copernicus Future 2050 4.5\")\n  future <- raster::stack(raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio01\", experiment = \"rcp45\", future_date = \"2050-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio02\", experiment = \"rcp45\", future_date = \"2050-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio03\", experiment = \"rcp45\", future_date = \"2050-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio04\", experiment = \"rcp45\", future_date = \"2050-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio05\", experiment = \"rcp45\", future_date = \"2050-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio06\", experiment = \"rcp45\", future_date = \"2050-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio07\", experiment = \"rcp45\", future_date = \"2050-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio08\", experiment = \"rcp45\", future_date = \"2050-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio09\", experiment = \"rcp45\", future_date = \"2050-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio10\", experiment = \"rcp45\", future_date = \"2050-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio11\", experiment = \"rcp45\", future_date = \"2050-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio12\", experiment = \"rcp45\", future_date = \"2050-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio13\", experiment = \"rcp45\", future_date = \"2050-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio14\", experiment = \"rcp45\", future_date = \"2050-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio15\", experiment = \"rcp45\", future_date = \"2050-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio16\", experiment = \"rcp45\", future_date = \"2050-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio17\", experiment = \"rcp45\", future_date = \"2050-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio18\", experiment = \"rcp45\", future_date = \"2050-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio19\", experiment = \"rcp45\", future_date = \"2050-01-01\"))\n  )\n  \n  sendstatus(\"Writing Copernicus Future 2050 4.5\")\n  rpostgis::pgWriteRast(con,\n                        name = \"future_2050_4_5\", raster = future, overwrite = TRUE\n  )\n  rm(future)\n  gc()\n  } else {\n    cat(\"Raster layers exist in Postgres. Skipping. \")\n}\n  \n  \n########################## Future 2050 8.5 Raster ############################\nif (!RPostgres::dbExistsTable(conn = con, name = \"future_2050_8_5\")) {\n  sendstatus(\"starting with reading Copernicus Future 2050 8.5\")\n  future <- raster::stack(raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio01\", experiment = \"rcp85\", future_date = \"2050-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio02\", experiment = \"rcp85\", future_date = \"2050-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio03\", experiment = \"rcp85\", future_date = \"2050-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio04\", experiment = \"rcp85\", future_date = \"2050-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio05\", experiment = \"rcp85\", future_date = \"2050-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio06\", experiment = \"rcp85\", future_date = \"2050-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio07\", experiment = \"rcp85\", future_date = \"2050-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio08\", experiment = \"rcp85\", future_date = \"2050-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio09\", experiment = \"rcp85\", future_date = \"2050-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio10\", experiment = \"rcp85\", future_date = \"2050-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio11\", experiment = \"rcp85\", future_date = \"2050-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio12\", experiment = \"rcp85\", future_date = \"2050-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio13\", experiment = \"rcp85\", future_date = \"2050-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio14\", experiment = \"rcp85\", future_date = \"2050-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio15\", experiment = \"rcp85\", future_date = \"2050-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio16\", experiment = \"rcp85\", future_date = \"2050-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio17\", experiment = \"rcp85\", future_date = \"2050-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio18\", experiment = \"rcp85\", future_date = \"2050-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio19\", experiment = \"rcp85\", future_date = \"2050-01-01\"))\n  )\n  \n  sendstatus(\"Writing Copernicus Future 2050 8.5\")\n  rpostgis::pgWriteRast(con,\n                        name = \"future_2050_8_5\", raster = future, overwrite = TRUE\n  )\n  rm(future)\n  gc()\n} else {\n  cat(\"Raster layers exist in Postgres. Skipping. \")\n}\n\n########################## Future 2070 4.5 Raster ############################\nif (!RPostgres::dbExistsTable(conn = con, name = \"future_2070_4_5\")) {\n  sendstatus(\"starting with reading Copernicus Future 2070 4.5\")\n  future <- raster::stack(raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio01\", experiment = \"rcp45\", future_date = \"2070-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio02\", experiment = \"rcp45\", future_date = \"2070-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio03\", experiment = \"rcp45\", future_date = \"2070-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio04\", experiment = \"rcp45\", future_date = \"2070-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio05\", experiment = \"rcp45\", future_date = \"2070-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio06\", experiment = \"rcp45\", future_date = \"2070-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio07\", experiment = \"rcp45\", future_date = \"2070-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio08\", experiment = \"rcp45\", future_date = \"2070-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio09\", experiment = \"rcp45\", future_date = \"2070-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio10\", experiment = \"rcp45\", future_date = \"2070-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio11\", experiment = \"rcp45\", future_date = \"2070-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio12\", experiment = \"rcp45\", future_date = \"2070-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio13\", experiment = \"rcp45\", future_date = \"2070-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio14\", experiment = \"rcp45\", future_date = \"2070-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio15\", experiment = \"rcp45\", future_date = \"2070-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio16\", experiment = \"rcp45\", future_date = \"2070-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio17\", experiment = \"rcp45\", future_date = \"2070-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio18\", experiment = \"rcp45\", future_date = \"2070-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio19\", experiment = \"rcp45\", future_date = \"2070-01-01\"))\n  )\n  \n  sendstatus(\"Writing Copernicus Future 2070 4.5\")\n  rpostgis::pgWriteRast(con,\n                        name = \"future_2070_4_5\", raster = future, overwrite = TRUE\n  )\n  rm(future)\n  gc()\n} else {\n  cat(\"Raster layers exist in Postgres. Skipping. \")\n}\n\n\n########################## Future 2070 8.5 Raster ############################\nif (!RPostgres::dbExistsTable(conn = con, name = \"future_2070_8_5\")) {\n  sendstatus(\"starting with reading Copernicus Future 2070 8.5\")\n  future <- raster::stack(raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio01\", experiment = \"rcp85\", future_date = \"2070-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio02\", experiment = \"rcp85\", future_date = \"2070-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio03\", experiment = \"rcp85\", future_date = \"2070-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio04\", experiment = \"rcp85\", future_date = \"2070-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio05\", experiment = \"rcp85\", future_date = \"2070-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio06\", experiment = \"rcp85\", future_date = \"2070-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio07\", experiment = \"rcp85\", future_date = \"2070-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio08\", experiment = \"rcp85\", future_date = \"2070-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio09\", experiment = \"rcp85\", future_date = \"2070-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio10\", experiment = \"rcp85\", future_date = \"2070-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio11\", experiment = \"rcp85\", future_date = \"2070-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio12\", experiment = \"rcp85\", future_date = \"2070-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio13\", experiment = \"rcp85\", future_date = \"2070-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio14\", experiment = \"rcp85\", future_date = \"2070-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio15\", experiment = \"rcp85\", future_date = \"2070-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio16\", experiment = \"rcp85\", future_date = \"2070-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio17\", experiment = \"rcp85\", future_date = \"2070-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio18\", experiment = \"rcp85\", future_date = \"2070-01-01\")),\n                          raster::raster(getfutureclimate(source = \"copernicus\", bioclim = \"bio19\", experiment = \"rcp85\", future_date = \"2070-01-01\"))\n  )\n  \n  sendstatus(\"Writing Copernicus Future 2070 8.5\")\n  rpostgis::pgWriteRast(con,\n                        name = \"future_2070_8_5\", raster = future, overwrite = TRUE\n  )\n  rm(future)\n  gc()\n} else {\n  cat(\"Raster layers exist in Postgres. Skipping. \")\n}\n  \n  \n  print(\"Reading in Soil Rasters\")\n  soil <- raster::stack(raster::raster(getsoilproperties(\"STU_EU_DEPTH_ROOTS\")),\n                        raster::raster(getsoilproperties(\"STU_EU_T_CLAY\")),\n                        raster::raster(getsoilproperties(\"STU_EU_S_CLAY\")),\n                        raster::raster(getsoilproperties(\"STU_EU_T_SAND\")),\n                        raster::raster(getsoilproperties(\"STU_EU_S_SAND\")),\n                        raster::raster(getsoilproperties(\"STU_EU_T_SILT\")),\n                        raster::raster(getsoilproperties(\"STU_EU_S_SILT\")),\n                        raster::raster(getsoilproperties(\"STU_EU_T_OC\")),\n                        raster::raster(getsoilproperties(\"STU_EU_S_OC\")),\n                        raster::raster(getsoilproperties(\"STU_EU_T_BD\")),\n                        raster::raster(getsoilproperties(\"STU_EU_S_BD\")),\n                        raster::raster(getsoilproperties(\"STU_EU_T_GRAVEL\")),\n                        raster::raster(getsoilproperties(\"STU_EU_S_GRAVEL\")),\n                        raster::raster(getsoilproperties(\"SMU_EU_T_TAWC\")),\n                        raster::raster(getsoilproperties(\"SMU_EU_S_TAWC\")),\n                        raster::raster(getsoilproperties(\"STU_EU_T_TAWC\")),\n                        raster::raster(getsoilproperties(\"STU_EU_S_TAWC\"))\n  )\n  \n  \n  print(\"Writing Soil to DB\")\n  rpostgis::pgWriteRast(con,\n                        name = \"soil\", raster = soil, overwrite = TRUE\n  )\n  rm(soil)\n  gc()\n  \n\n\n\n\nDBI::dbDisconnect(conn = con)\n\n\n\n\nOption 2: Mount raster files into Shiny container\nThe raster files downloaded from Copernicus CDS can simply be mounted into the Docker container. See our docker-compose for details on this."
  },
  {
    "objectID": "index.html#shiny-app-development",
    "href": "index.html#shiny-app-development",
    "title": "Treeful Docs",
    "section": "Shiny App Development",
    "text": "Shiny App Development\nThe shiny app itself is developed as package using the golem framework. Most of the server and ui code explains itself."
  },
  {
    "objectID": "index.html#database-deployment",
    "href": "index.html#database-deployment",
    "title": "Treeful Docs",
    "section": "Database Deployment",
    "text": "Database Deployment\nWe use the docker image postgis/postgis and only add raster extension to it with a short init script.\n\n\nCode\nfrom postgis/postgis\n# need to enable raster extentions\n\n\nCOPY ./initialize-raster.sh /docker-entrypoint-initdb.d/initialize-raster.sh\n# CREATE EXTENSION postgis_raster;\n# SET postgis.gdal_enabled_drivers = 'ENABLE_ALL';\n# SELECT name, default_version,installed_version\n# FROM pg_available_extensions WHERE name LIKE 'postgis%' or name LIKE 'address%';"
  },
  {
    "objectID": "index.html#shiny-app-deployment",
    "href": "index.html#shiny-app-deployment",
    "title": "Treeful Docs",
    "section": "Shiny App Deployment",
    "text": "Shiny App Deployment\n\nRunning the package barebone in a Docker container\nThis approach means the R process will simply launch the shiny app. For a more robust deployment, use Shiny Server.\n\nGenerate the Dockerfile from the app. Golem handles this with golem::add_dockerfile() but you need to edit the Dockerfile by hand. When adding new packages, ensure they’re at the end of the Dockerfile in order to leverage build caching.\nOn your host: clone the repository with git clone https://github.com/3ful/treeful.git and move to the directory with cd ./treeful\nRun stack with swarm and compose\n\nlaunch your docker swarm: docker swarm init\nIf this is the first time running, the Postgis DB will be empty and you need to supply a first user password. While ETL is running the Shiny will not find any data.\nIn order to serve the same image to all nodes you need a docker registry. Create one with: docker service create --name registry --publish published=5000,target=5000 registry:2\nPush images to registry: docker compose push\nNow, deploy your swarm: docker stack deploy --compose-file docker-compose.yml treeful\nNow you can easily scale up your shiny app to 3 replicas with docker service scale treeful_frontend=3\nYou can watch visitors of your frontend app with docker service logs treeful_frontend -f\n\n\n\n\nRunning in Shiny Server\nThis is the better option for serving the app to multiple users. Our Dockerfile in 3_shiny_frontend uses this approach. Important aspects:\n\nYou can use rocker images, such as shiny-verse.\nMake the folder /srv/shiny-server readable by user shiny. Otherwise cache folder cannot be written and performance might suffer.\nWhen building the frontend container: the database container needs to be running and you need to make sure secrets are mounted and available during the package install. Remember, the shiny app is a package.\ngolem::add_shinyserver_file() will generate an app.R file. Shiny server needs that.\n\n\n\nRunning in Shinyproxy\nWe abandoned this option. The main reason was that shinyproxy spins up containers for each user. Since this app requires a fair amount of Ram, it didn’t serve our needs. If you need authentication, this is your option."
  }
]